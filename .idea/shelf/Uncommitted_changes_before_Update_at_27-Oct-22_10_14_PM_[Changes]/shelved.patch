Index: src/GameObject/entity/Oneal.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package GameObject.entity;\r\n\r\nimport main.GamePanel;\r\n\r\nimport javax.imageio.ImageIO;\r\nimport java.awt.*;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.IOException;\r\nimport java.util.Objects;\r\n\r\npublic class Oneal extends Entity {\r\n    public int actionLockCounter = 0;\r\n    BufferedImage[] onealLeft = new BufferedImage[3];\r\n    BufferedImage[] onealRight = new BufferedImage[3];\r\n\r\n\r\n    public Oneal(GamePanel gp) {\r\n        super(gp);\r\n        direction = \"down\";\r\n        preDirection = \"\";\r\n        speed = 2;\r\n        width = gp.tileSize;\r\n        height = gp.tileSize;\r\n        getImage();\r\n    }\r\n\r\n    public void setEnemies(int x, int y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    public void getImage() {\r\n        try {\r\n            onealLeft[0] = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream(\"/GameObject/sprites/enemy/oneal_left1.png\")));\r\n            onealLeft[1] = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream(\"/GameObject/sprites/enemy/oneal_left2.png\")));\r\n            onealLeft[2] = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream(\"/GameObject/sprites/enemy/oneal_left3.png\")));\r\n\r\n            onealRight[0] = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream(\"/GameObject/sprites/enemy/oneal_right1.png\")));\r\n            onealRight[1] = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream(\"/GameObject/sprites/enemy/oneal_right2.png\")));\r\n            onealRight[2] = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream(\"/GameObject/sprites/enemy/oneal_right3.png\")));\r\n\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void setAction() {\r\n        int bomber_x = gp.bomberman.x / gp.tileSize;\r\n        int bomber_y = gp.bomberman.y / gp.tileSize;\r\n        int oneal_x = x / gp.tileSize;\r\n        int oneal_y = y / gp.tileSize;\r\n        int smartX = oneal_x - bomber_x;\r\n        int smartY = oneal_y - bomber_y;\r\n        actionLockCounter++;\r\n        if (actionLockCounter == 60) {\r\n            if (smartX * smartX - smartY * smartY > 0) {\r\n                if (smartX < 0) {\r\n                    direction = \"right\";\r\n                }\r\n                if (smartX > 0) {\r\n                    direction = \"left\";\r\n                }\r\n            } else {\r\n                if (smartY > 0) {\r\n                    direction = \"up\";\r\n                } else {\r\n                    direction = \"down\";\r\n                }\r\n            }\r\n            System.out.println(gp.bomberman.x + \" \" + gp.bomberman.y);\r\n            System.out.println(smartX + \" \" + smartY);\r\n            actionLockCounter = 0;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void update() {\r\n        setAction();\r\n        switch (direction) {\r\n            case \"up\" -> {\r\n                if (!collisionUp()) {\r\n                    y -= speed;\r\n                }\r\n            }\r\n            case \"down\" -> {\r\n                if (!collisionDown()) {\r\n                    y += speed;\r\n                }\r\n            }\r\n            case \"left\" -> {\r\n                if (!collisionLeft()) {\r\n                    x -= speed;\r\n                }\r\n            }\r\n            case \"right\" -> {\r\n                if (!collisionRight()) {\r\n                    x += speed;\r\n                }\r\n            }\r\n        }\r\n        spriteCounter++;\r\n        if (spriteCounter > 12) {\r\n            if (spriteNum == 1) {\r\n                spriteNum = 2;\r\n            } else if (spriteNum == 2) {\r\n                spriteNum = 1;\r\n            }\r\n            spriteCounter = 0;\r\n        }\r\n    }\r\n\r\n\r\n    public void draw(Graphics2D g2) {\r\n        if (gp.bomberman.x <= gp.screenWidth / 2) {\r\n            if (direction.equals(\"left\")) {\r\n                g2.drawImage(onealLeft[spriteNum], x, y, gp.tileSize, gp.tileSize, null);\r\n            } else if (direction.equals(\"right\")) {\r\n                g2.drawImage(onealRight[spriteNum], x, y, gp.tileSize, gp.tileSize, null);\r\n            } else {\r\n                if (preDirection.equals(\"left\")) {\r\n                    g2.drawImage(onealLeft[spriteNum], x, y, gp.tileSize, gp.tileSize, null);\r\n                } else {\r\n                    g2.drawImage(onealRight[spriteNum], x, y, gp.tileSize, gp.tileSize, null);\r\n                }\r\n            }\r\n        } else if (gp.screenWidth / 2 <= gp.bomberman.x && gp.bomberman.x < gp.worldWidth - gp.screenWidth / 2 && x >= gp.screenWidth / 2) {\r\n            int ScreenX = x + gp.screenWidth / 2 - gp.bomberman.x;\r\n            if (direction.equals(\"left\")) {\r\n                g2.drawImage(onealLeft[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n            } else if (direction.equals(\"right\")) {\r\n                g2.drawImage(onealRight[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n            } else {\r\n                if (preDirection.equals(\"left\")) {\r\n                    g2.drawImage(onealLeft[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n                } else {\r\n                    g2.drawImage(onealRight[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n                }\r\n            }\r\n        } else if (gp.screenWidth / 2 <= gp.bomberman.x && x < gp.screenWidth / 2) {\r\n            int ScreenX = gp.screenWidth / 2 + this.x - gp.bomberman.x;\r\n            if (direction.equals(\"left\")) {\r\n                g2.drawImage(onealLeft[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n            } else if (direction.equals(\"right\")) {\r\n                g2.drawImage(onealRight[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n            } else {\r\n                if (preDirection.equals(\"left\")) {\r\n                    g2.drawImage(onealLeft[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n                } else {\r\n                    g2.drawImage(onealRight[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n                }\r\n            }\r\n        } else if (gp.bomberman.x > gp.worldWidth - gp.screenWidth / 2) {\r\n            int ScreenX = x - gp.worldWidth + gp.screenWidth;\r\n            if (direction.equals(\"left\")) {\r\n                g2.drawImage(onealLeft[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n            } else if (direction.equals(\"right\")) {\r\n                g2.drawImage(onealRight[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n            } else {\r\n                if (preDirection.equals(\"left\")) {\r\n                    g2.drawImage(onealLeft[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n                } else {\r\n                    g2.drawImage(onealRight[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/GameObject/entity/Oneal.java b/src/GameObject/entity/Oneal.java
--- a/src/GameObject/entity/Oneal.java	(revision 1b1b81bc9f07efbdcf56268eb6e35798f17c5433)
+++ b/src/GameObject/entity/Oneal.java	(date 1666883337538)
@@ -13,6 +13,15 @@
     BufferedImage[] onealLeft = new BufferedImage[3];
     BufferedImage[] onealRight = new BufferedImage[3];
 
+    public int intervalCount = 0;
+    public int speedUpInterval = 90;
+
+    public int bomber_x;
+    public int bomber_y;
+    public int oneal_x;
+    public int oneal_y;
+    public int smartX;
+    public int smartY;
 
     public Oneal(GamePanel gp) {
         super(gp);
@@ -45,68 +54,79 @@
     }
 
     public void setAction() {
-        int bomber_x = gp.bomberman.x / gp.tileSize;
-        int bomber_y = gp.bomberman.y / gp.tileSize;
-        int oneal_x = x / gp.tileSize;
-        int oneal_y = y / gp.tileSize;
-        int smartX = oneal_x - bomber_x;
-        int smartY = oneal_y - bomber_y;
+        bomber_x = gp.bomberman.x ;
+        bomber_y = gp.bomberman.y ;
+        oneal_x = x ;
+        oneal_y = y ;
+        smartX = oneal_x - bomber_x;
+        smartY = oneal_y - bomber_y;
         actionLockCounter++;
-        if (actionLockCounter == 60) {
-            if (smartX * smartX - smartY * smartY > 0) {
+        if (actionLockCounter == 40) {
+            randomSpeed();
+            System.out.println("b:" + gp.bomberman.x + " " + gp.bomberman.y);
+            System.out.println("o:" + x + " " + y);
+            if (smartX * smartX - smartY * smartY >= 0) {
                 if (smartX < 0) {
                     direction = "right";
+                    if (smartY < 0) {
+                        direction = "down";
+                    }
+                    if (smartY > 0) {
+                        direction = "up";
+                    }
                 }
                 if (smartX > 0) {
                     direction = "left";
+                    if (smartY < 0) {
+                        direction = "down";
+                    }
+                    if (smartY > 0) {
+                        direction = "up";
+                    }
                 }
-            } else {
+            }
+            if (smartX * smartX - smartY * smartY <= 0) {
                 if (smartY > 0) {
                     direction = "up";
-                } else {
+                    preDirection = "up";
+                    if (smartX > 0) {
+                        direction = "left";
+                    }
+                    if (smartX < 0) {
+                        direction = "right";
+                    }
+                }
+                if (smartY < 0) {
                     direction = "down";
+                    preDirection = "down";
+                    if (smartX > 0) {
+                        direction = "left";
+                    }
+                    if (smartX < 0) {
+                        direction = "right";
+                    }
                 }
             }
-            System.out.println(gp.bomberman.x + " " + gp.bomberman.y);
-            System.out.println(smartX + " " + smartY);
+
             actionLockCounter = 0;
         }
     }
 
+    public void randomSpeed() {
+        intervalCount++;
+        if (intervalCount == speedUpInterval / 6) {
+            speed = 2;
+        }
+        if (intervalCount == speedUpInterval) {
+            speed = 3;
+            intervalCount = 0;
+        }
+    }
+
     @Override
     public void update() {
         setAction();
-        switch (direction) {
-            case "up" -> {
-                if (!collisionUp()) {
-                    y -= speed;
-                }
-            }
-            case "down" -> {
-                if (!collisionDown()) {
-                    y += speed;
-                }
-            }
-            case "left" -> {
-                if (!collisionLeft()) {
-                    x -= speed;
-                }
-            }
-            case "right" -> {
-                if (!collisionRight()) {
-                    x += speed;
-                }
-            }
-        }
-        spriteCounter++;
-        if (spriteCounter > 12) {
-            if (spriteNum == 1) {
-                spriteNum = 2;
-            } else if (spriteNum == 2) {
-                spriteNum = 1;
-            }
-            spriteCounter = 0;
-        }
+        super.updatePos();
     }
 
 
Index: src/GameObject/entity/Entity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package GameObject.entity;\r\n\r\nimport GameObject.Gameobject;\r\nimport GameObject.Item.BrickBombItem;\r\nimport GameObject.Item.BrickFlameItem;\r\nimport GameObject.Item.BrickPortalItem;\r\nimport GameObject.Item.BrickSpeedItem;\r\nimport GameObject.Tiles.TileManager;\r\nimport GameObject.mapObject.Brick;\r\nimport GameObject.mapObject.Wall;\r\nimport GameObject.object.Bomb;\r\nimport main.GamePanel;\r\n\r\nimport java.awt.*;\r\nimport java.awt.image.BufferedImage;\r\nimport java.awt.image.BufferedImageFilter;\r\n\r\npublic class Entity extends Gameobject {\r\n    GamePanel gp;\r\n    public int speed;\r\n\r\n    //Load image\r\n    public BufferedImage up, up1, up2, down, down1, down2, left, left1, left2, right, right1, right2, dead1, dead2, dead3;\r\n    public String direction;\r\n    public String preDirection;\r\n\r\n    //Animation\r\n    public int spriteCounter = 0;\r\n    public int spriteNum = 1;\r\n\r\n    public Entity(GamePanel gp) {\r\n        this.gp = gp;\r\n    }\r\n\r\n    public void setAction() {\r\n    }\r\n\r\n    public void update() {\r\n    }\r\n\r\n    public void draw(Graphics2D g2) {\r\n    }\r\n\r\n    @Override\r\n    public Rectangle getBound() {\r\n        return null;\r\n    }\r\n\r\n    public Rectangle getBound(int x, int y) {\r\n        return new Rectangle(x, y + height, width, height);\r\n    }\r\n    public boolean collisionUp() {\r\n        int a = x % gp.tileSize;\r\n        int b = y % gp.tileSize;\r\n        int EntityX = x / gp.tileSize;\r\n        int EntityY = y / gp.tileSize;\r\n        if (this.getBound(x, y - speed).intersects(TileManager.obj[EntityY - 1][EntityX].getBound()) && (TileManager.obj[EntityY - 1][EntityX] instanceof Wall || TileManager.obj[EntityY - 1][EntityX] instanceof Brick || TileManager.obj[EntityY - 1][EntityX] instanceof BrickFlameItem || TileManager.obj[EntityY - 1][EntityX] instanceof BrickSpeedItem || TileManager.obj[EntityY - 1][EntityX] instanceof BrickBombItem  || TileManager.obj[EntityY - 1][EntityX] instanceof Bomb || TileManager.obj[EntityY - 1][EntityX] instanceof BrickPortalItem)) {\r\n            return true;\r\n        } else if (this.getBound(x, y - speed).intersects(TileManager.obj[EntityY - 1][EntityX].getBound()) && (TileManager.obj[EntityY - 1][EntityX] instanceof Wall || TileManager.obj[EntityY - 1][EntityX] instanceof Brick || TileManager.obj[EntityY - 1][EntityX] instanceof BrickFlameItem || TileManager.obj[EntityY - 1][EntityX] instanceof BrickBombItem || TileManager.obj[EntityY - 1][EntityX] instanceof BrickSpeedItem  || TileManager.obj[EntityY - 1][EntityX] instanceof Bomb || TileManager.obj[EntityY - 1][EntityX] instanceof BrickPortalItem) && a > 16) {\r\n            return true;\r\n        } else if (this.getBound(x, y - speed).intersects(TileManager.obj[EntityY - 1][EntityX + 1].getBound()) && (TileManager.obj[EntityY - 1][EntityX + 1] instanceof Wall || TileManager.obj[EntityY - 1][EntityX + 1] instanceof Brick || TileManager.obj[EntityY - 1][EntityX + 1] instanceof Bomb || TileManager.obj[EntityY - 1][EntityX + 1] instanceof BrickFlameItem || TileManager.obj[EntityY - 1][EntityX+1] instanceof BrickBombItem || TileManager.obj[EntityY - 1][EntityX+1] instanceof BrickSpeedItem || TileManager.obj[EntityY - 1][EntityX+1] instanceof BrickPortalItem) && a > 16) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n\r\n    }\r\n\r\n    public boolean collisionDown() {\r\n        int a = x % gp.tileSize;\r\n        int b = y % gp.tileSize;\r\n        int EntityX = x / gp.tileSize;\r\n        int EntityY = y / gp.tileSize;\r\n        if (this.getBound(x, y + speed).intersects(TileManager.obj[EntityY + 1][EntityX].getBound()) && (TileManager.obj[EntityY + 1][EntityX] instanceof Wall || TileManager.obj[EntityY + 1][EntityX] instanceof Brick || TileManager.obj[EntityY + 1][EntityX] instanceof BrickFlameItem || TileManager.obj[EntityY + 1][EntityX] instanceof BrickSpeedItem || TileManager.obj[EntityY + 1][EntityX] instanceof BrickBombItem || TileManager.obj[EntityY + 1][EntityX] instanceof Bomb || TileManager.obj[EntityY + 1][EntityX] instanceof BrickPortalItem)) {\r\n            return true;\r\n        } else if (this.getBound(x, y + speed).intersects(TileManager.obj[EntityY + 1][EntityX].getBound()) && (TileManager.obj[EntityY + 1][EntityX] instanceof Wall || TileManager.obj[EntityY + 1][EntityX] instanceof Brick || TileManager.obj[EntityY + 1][EntityX] instanceof BrickBombItem || TileManager.obj[EntityY + 1][EntityX] instanceof BrickSpeedItem || TileManager.obj[EntityY + 1][EntityX] instanceof BrickFlameItem  || TileManager.obj[EntityY + 1][EntityX] instanceof BrickPortalItem || TileManager.obj[EntityY + 1][EntityX] instanceof Bomb) && a > 16) {\r\n            return true;\r\n        } else if (this.getBound(x, y + speed).intersects(TileManager.obj[EntityY + 1][EntityX + 1].getBound()) && (TileManager.obj[EntityY + 1][EntityX + 1] instanceof Wall || TileManager.obj[EntityY + 1][EntityX + 1] instanceof Brick || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickSpeedItem || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickFlameItem || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickBombItem || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickPortalItem || TileManager.obj[EntityY + 1][EntityX + 1] instanceof Bomb) && a > 16) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean collisionRight() {\r\n        int EntityX = x / gp.tileSize;\r\n        int EntityY = y / gp.tileSize;\r\n        if (this.getBound(x + speed, y).intersects(TileManager.obj[EntityY][EntityX + 1].getBound()) && (TileManager.obj[EntityY][EntityX + 1] instanceof Wall || TileManager.obj[EntityY][EntityX + 1] instanceof Brick || TileManager.obj[EntityY][EntityX + 1] instanceof BrickSpeedItem ||TileManager.obj[EntityY][EntityX + 1] instanceof BrickFlameItem || TileManager.obj[EntityY][EntityX + 1] instanceof BrickBombItem || TileManager.obj[EntityY][EntityX + 1] instanceof Bomb  || TileManager.obj[EntityY][EntityX + 1] instanceof BrickPortalItem)) {\r\n            return true;\r\n        } else if (this.getBound(x + speed, y).intersects(TileManager.obj[EntityY + 1][EntityX + 1].getBound()) && (TileManager.obj[EntityY + 1][EntityX + 1] instanceof Wall || TileManager.obj[EntityY + 1][EntityX + 1] instanceof Brick || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickBombItem || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickSpeedItem || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickFlameItem || TileManager.obj[EntityY + 1][EntityX + 1] instanceof Bomb || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickPortalItem)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean collisionLeft() {\r\n        int EntityX = x / gp.tileSize;\r\n        int EntityY = y / gp.tileSize;\r\n        if (this.getBound(x - speed, y).intersects(TileManager.obj[EntityY][EntityX - 1].getBound()) && (TileManager.obj[EntityY][EntityX - 1] instanceof Wall || TileManager.obj[EntityY][EntityX - 1] instanceof Brick || TileManager.obj[EntityY][EntityX - 1] instanceof BrickSpeedItem || TileManager.obj[EntityY][EntityX - 1] instanceof BrickFlameItem || TileManager.obj[EntityY][EntityX - 1] instanceof BrickBombItem || TileManager.obj[EntityY][EntityX - 1] instanceof Bomb || TileManager.obj[EntityY][EntityX - 1] instanceof BrickPortalItem)) {\r\n            return true;\r\n        } else if (this.getBound(x - speed, y).intersects(TileManager.obj[EntityY + 1][EntityX - 1].getBound()) && (TileManager.obj[EntityY + 1][EntityX - 1] instanceof Wall || TileManager.obj[EntityY + 1][EntityX - 1] instanceof Brick || TileManager.obj[EntityY + 1][EntityX - 1] instanceof BrickBombItem || TileManager.obj[EntityY + 1][EntityX - 1] instanceof BrickFlameItem || TileManager.obj[EntityY + 1][EntityX - 1] instanceof BrickSpeedItem || TileManager.obj[EntityY+1][EntityX - 1] instanceof BrickPortalItem || TileManager.obj[EntityY+1][EntityX - 1] instanceof Bomb)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/GameObject/entity/Entity.java b/src/GameObject/entity/Entity.java
--- a/src/GameObject/entity/Entity.java	(revision 1b1b81bc9f07efbdcf56268eb6e35798f17c5433)
+++ b/src/GameObject/entity/Entity.java	(date 1666805916745)
@@ -41,6 +41,38 @@
     public void draw(Graphics2D g2) {
     }
 
+    public void updatePos() {
+        if (direction.equals("up")) {
+            if (!collisionUp()) {
+                y -= speed;
+            }
+        }
+        if (direction.equals("down")) {
+            if (!collisionDown()) {
+                y += speed;
+            }
+        }
+        if (direction.equals("left")) {
+            if (!collisionLeft()) {
+                x -= speed;
+            }
+        }
+        if (direction.equals("right")) {
+            if (!collisionRight()) {
+                x += speed;
+            }
+        }
+        spriteCounter++;
+        if (spriteCounter > 12) {
+            if (spriteNum == 1) {
+                spriteNum = 2;
+            } else if (spriteNum == 2) {
+                spriteNum = 1;
+            }
+            spriteCounter = 0;
+        }
+    }
+
     @Override
     public Rectangle getBound() {
         return null;
@@ -49,16 +81,17 @@
     public Rectangle getBound(int x, int y) {
         return new Rectangle(x, y + height, width, height);
     }
+
     public boolean collisionUp() {
         int a = x % gp.tileSize;
         int b = y % gp.tileSize;
         int EntityX = x / gp.tileSize;
         int EntityY = y / gp.tileSize;
-        if (this.getBound(x, y - speed).intersects(TileManager.obj[EntityY - 1][EntityX].getBound()) && (TileManager.obj[EntityY - 1][EntityX] instanceof Wall || TileManager.obj[EntityY - 1][EntityX] instanceof Brick || TileManager.obj[EntityY - 1][EntityX] instanceof BrickFlameItem || TileManager.obj[EntityY - 1][EntityX] instanceof BrickSpeedItem || TileManager.obj[EntityY - 1][EntityX] instanceof BrickBombItem  || TileManager.obj[EntityY - 1][EntityX] instanceof Bomb || TileManager.obj[EntityY - 1][EntityX] instanceof BrickPortalItem)) {
+        if (this.getBound(x, y - speed).intersects(TileManager.obj[EntityY - 1][EntityX].getBound()) && (TileManager.obj[EntityY - 1][EntityX] instanceof Wall || TileManager.obj[EntityY - 1][EntityX] instanceof Brick || TileManager.obj[EntityY - 1][EntityX] instanceof BrickFlameItem || TileManager.obj[EntityY - 1][EntityX] instanceof BrickSpeedItem || TileManager.obj[EntityY - 1][EntityX] instanceof BrickBombItem || TileManager.obj[EntityY - 1][EntityX] instanceof Bomb || TileManager.obj[EntityY - 1][EntityX] instanceof BrickPortalItem)) {
             return true;
-        } else if (this.getBound(x, y - speed).intersects(TileManager.obj[EntityY - 1][EntityX].getBound()) && (TileManager.obj[EntityY - 1][EntityX] instanceof Wall || TileManager.obj[EntityY - 1][EntityX] instanceof Brick || TileManager.obj[EntityY - 1][EntityX] instanceof BrickFlameItem || TileManager.obj[EntityY - 1][EntityX] instanceof BrickBombItem || TileManager.obj[EntityY - 1][EntityX] instanceof BrickSpeedItem  || TileManager.obj[EntityY - 1][EntityX] instanceof Bomb || TileManager.obj[EntityY - 1][EntityX] instanceof BrickPortalItem) && a > 16) {
+        } else if (this.getBound(x, y - speed).intersects(TileManager.obj[EntityY - 1][EntityX].getBound()) && (TileManager.obj[EntityY - 1][EntityX] instanceof Wall || TileManager.obj[EntityY - 1][EntityX] instanceof Brick || TileManager.obj[EntityY - 1][EntityX] instanceof BrickFlameItem || TileManager.obj[EntityY - 1][EntityX] instanceof BrickBombItem || TileManager.obj[EntityY - 1][EntityX] instanceof BrickSpeedItem || TileManager.obj[EntityY - 1][EntityX] instanceof Bomb || TileManager.obj[EntityY - 1][EntityX] instanceof BrickPortalItem) && a > 16) {
             return true;
-        } else if (this.getBound(x, y - speed).intersects(TileManager.obj[EntityY - 1][EntityX + 1].getBound()) && (TileManager.obj[EntityY - 1][EntityX + 1] instanceof Wall || TileManager.obj[EntityY - 1][EntityX + 1] instanceof Brick || TileManager.obj[EntityY - 1][EntityX + 1] instanceof Bomb || TileManager.obj[EntityY - 1][EntityX + 1] instanceof BrickFlameItem || TileManager.obj[EntityY - 1][EntityX+1] instanceof BrickBombItem || TileManager.obj[EntityY - 1][EntityX+1] instanceof BrickSpeedItem || TileManager.obj[EntityY - 1][EntityX+1] instanceof BrickPortalItem) && a > 16) {
+        } else if (this.getBound(x, y - speed).intersects(TileManager.obj[EntityY - 1][EntityX + 1].getBound()) && (TileManager.obj[EntityY - 1][EntityX + 1] instanceof Wall || TileManager.obj[EntityY - 1][EntityX + 1] instanceof Brick || TileManager.obj[EntityY - 1][EntityX + 1] instanceof Bomb || TileManager.obj[EntityY - 1][EntityX + 1] instanceof BrickFlameItem || TileManager.obj[EntityY - 1][EntityX + 1] instanceof BrickBombItem || TileManager.obj[EntityY - 1][EntityX + 1] instanceof BrickSpeedItem || TileManager.obj[EntityY - 1][EntityX + 1] instanceof BrickPortalItem) && a > 16) {
             return true;
         } else {
             return false;
@@ -73,7 +106,7 @@
         int EntityY = y / gp.tileSize;
         if (this.getBound(x, y + speed).intersects(TileManager.obj[EntityY + 1][EntityX].getBound()) && (TileManager.obj[EntityY + 1][EntityX] instanceof Wall || TileManager.obj[EntityY + 1][EntityX] instanceof Brick || TileManager.obj[EntityY + 1][EntityX] instanceof BrickFlameItem || TileManager.obj[EntityY + 1][EntityX] instanceof BrickSpeedItem || TileManager.obj[EntityY + 1][EntityX] instanceof BrickBombItem || TileManager.obj[EntityY + 1][EntityX] instanceof Bomb || TileManager.obj[EntityY + 1][EntityX] instanceof BrickPortalItem)) {
             return true;
-        } else if (this.getBound(x, y + speed).intersects(TileManager.obj[EntityY + 1][EntityX].getBound()) && (TileManager.obj[EntityY + 1][EntityX] instanceof Wall || TileManager.obj[EntityY + 1][EntityX] instanceof Brick || TileManager.obj[EntityY + 1][EntityX] instanceof BrickBombItem || TileManager.obj[EntityY + 1][EntityX] instanceof BrickSpeedItem || TileManager.obj[EntityY + 1][EntityX] instanceof BrickFlameItem  || TileManager.obj[EntityY + 1][EntityX] instanceof BrickPortalItem || TileManager.obj[EntityY + 1][EntityX] instanceof Bomb) && a > 16) {
+        } else if (this.getBound(x, y + speed).intersects(TileManager.obj[EntityY + 1][EntityX].getBound()) && (TileManager.obj[EntityY + 1][EntityX] instanceof Wall || TileManager.obj[EntityY + 1][EntityX] instanceof Brick || TileManager.obj[EntityY + 1][EntityX] instanceof BrickBombItem || TileManager.obj[EntityY + 1][EntityX] instanceof BrickSpeedItem || TileManager.obj[EntityY + 1][EntityX] instanceof BrickFlameItem || TileManager.obj[EntityY + 1][EntityX] instanceof BrickPortalItem || TileManager.obj[EntityY + 1][EntityX] instanceof Bomb) && a > 16) {
             return true;
         } else if (this.getBound(x, y + speed).intersects(TileManager.obj[EntityY + 1][EntityX + 1].getBound()) && (TileManager.obj[EntityY + 1][EntityX + 1] instanceof Wall || TileManager.obj[EntityY + 1][EntityX + 1] instanceof Brick || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickSpeedItem || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickFlameItem || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickBombItem || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickPortalItem || TileManager.obj[EntityY + 1][EntityX + 1] instanceof Bomb) && a > 16) {
             return true;
@@ -85,7 +118,7 @@
     public boolean collisionRight() {
         int EntityX = x / gp.tileSize;
         int EntityY = y / gp.tileSize;
-        if (this.getBound(x + speed, y).intersects(TileManager.obj[EntityY][EntityX + 1].getBound()) && (TileManager.obj[EntityY][EntityX + 1] instanceof Wall || TileManager.obj[EntityY][EntityX + 1] instanceof Brick || TileManager.obj[EntityY][EntityX + 1] instanceof BrickSpeedItem ||TileManager.obj[EntityY][EntityX + 1] instanceof BrickFlameItem || TileManager.obj[EntityY][EntityX + 1] instanceof BrickBombItem || TileManager.obj[EntityY][EntityX + 1] instanceof Bomb  || TileManager.obj[EntityY][EntityX + 1] instanceof BrickPortalItem)) {
+        if (this.getBound(x + speed, y).intersects(TileManager.obj[EntityY][EntityX + 1].getBound()) && (TileManager.obj[EntityY][EntityX + 1] instanceof Wall || TileManager.obj[EntityY][EntityX + 1] instanceof Brick || TileManager.obj[EntityY][EntityX + 1] instanceof BrickSpeedItem || TileManager.obj[EntityY][EntityX + 1] instanceof BrickFlameItem || TileManager.obj[EntityY][EntityX + 1] instanceof BrickBombItem || TileManager.obj[EntityY][EntityX + 1] instanceof Bomb || TileManager.obj[EntityY][EntityX + 1] instanceof BrickPortalItem)) {
             return true;
         } else if (this.getBound(x + speed, y).intersects(TileManager.obj[EntityY + 1][EntityX + 1].getBound()) && (TileManager.obj[EntityY + 1][EntityX + 1] instanceof Wall || TileManager.obj[EntityY + 1][EntityX + 1] instanceof Brick || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickBombItem || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickSpeedItem || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickFlameItem || TileManager.obj[EntityY + 1][EntityX + 1] instanceof Bomb || TileManager.obj[EntityY + 1][EntityX + 1] instanceof BrickPortalItem)) {
             return true;
@@ -99,7 +132,7 @@
         int EntityY = y / gp.tileSize;
         if (this.getBound(x - speed, y).intersects(TileManager.obj[EntityY][EntityX - 1].getBound()) && (TileManager.obj[EntityY][EntityX - 1] instanceof Wall || TileManager.obj[EntityY][EntityX - 1] instanceof Brick || TileManager.obj[EntityY][EntityX - 1] instanceof BrickSpeedItem || TileManager.obj[EntityY][EntityX - 1] instanceof BrickFlameItem || TileManager.obj[EntityY][EntityX - 1] instanceof BrickBombItem || TileManager.obj[EntityY][EntityX - 1] instanceof Bomb || TileManager.obj[EntityY][EntityX - 1] instanceof BrickPortalItem)) {
             return true;
-        } else if (this.getBound(x - speed, y).intersects(TileManager.obj[EntityY + 1][EntityX - 1].getBound()) && (TileManager.obj[EntityY + 1][EntityX - 1] instanceof Wall || TileManager.obj[EntityY + 1][EntityX - 1] instanceof Brick || TileManager.obj[EntityY + 1][EntityX - 1] instanceof BrickBombItem || TileManager.obj[EntityY + 1][EntityX - 1] instanceof BrickFlameItem || TileManager.obj[EntityY + 1][EntityX - 1] instanceof BrickSpeedItem || TileManager.obj[EntityY+1][EntityX - 1] instanceof BrickPortalItem || TileManager.obj[EntityY+1][EntityX - 1] instanceof Bomb)) {
+        } else if (this.getBound(x - speed, y).intersects(TileManager.obj[EntityY + 1][EntityX - 1].getBound()) && (TileManager.obj[EntityY + 1][EntityX - 1] instanceof Wall || TileManager.obj[EntityY + 1][EntityX - 1] instanceof Brick || TileManager.obj[EntityY + 1][EntityX - 1] instanceof BrickBombItem || TileManager.obj[EntityY + 1][EntityX - 1] instanceof BrickFlameItem || TileManager.obj[EntityY + 1][EntityX - 1] instanceof BrickSpeedItem || TileManager.obj[EntityY + 1][EntityX - 1] instanceof BrickPortalItem || TileManager.obj[EntityY + 1][EntityX - 1] instanceof Bomb)) {
             return true;
         } else {
             return false;
Index: src/GameObject/entity/Enemies.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package GameObject.entity;\r\n\r\nimport main.GamePanel;\r\n\r\nimport javax.imageio.ImageIO;\r\nimport java.awt.*;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.IOException;\r\nimport java.util.Objects;\r\nimport java.util.Random;\r\n\r\nimport static GameObject.entity.Bomberman.intervalImageChange;\r\n\r\npublic class Enemies extends Entity {\r\n    public int actionLockCounter = 0;\r\n    BufferedImage[] balloonLeft = new BufferedImage[3];\r\n    BufferedImage[] balloonRight = new BufferedImage[3];\r\n\r\n    public Enemies(GamePanel gp) {\r\n        super(gp);\r\n        direction = \"down\";\r\n        preDirection = \"\";\r\n        speed = 2;\r\n        width = gp.tileSize;\r\n        height = gp.tileSize;\r\n        getImage();\r\n    }\r\n\r\n    public void setEnemies(int x, int y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    public void getImage() {\r\n        try {\r\n            //Balloon\r\n            balloonLeft[0] = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream(\"/GameObject/sprites/enemy/balloom_left1.png\")));\r\n            balloonLeft[1] = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream(\"/GameObject/sprites/enemy/balloom_left2.png\")));\r\n            balloonLeft[2] = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream(\"/GameObject/sprites/enemy/balloom_left3.png\")));\r\n\r\n            balloonRight[0] = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream(\"/GameObject/sprites/enemy/balloom_right1.png\")));\r\n            balloonRight[1] = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream(\"/GameObject/sprites/enemy/balloom_right2.png\")));\r\n            balloonRight[2] = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream(\"/GameObject/sprites/enemy/balloom_right3.png\")));\r\n\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void setAction() {\r\n        actionLockCounter++;\r\n        if (actionLockCounter == 120) {\r\n            Random random = new Random();\r\n            int i = random.nextInt(40) + 1;\r\n            if (i <= 10) {\r\n                direction = \"up\";\r\n                preDirection = \"up\";\r\n            }\r\n            if (i > 10 && i <= 20) {\r\n                direction = \"down\";\r\n                preDirection = \"down\";\r\n            }\r\n            if (i > 20 && i <= 30) {\r\n                direction = \"left\";\r\n            }\r\n            if (i > 30) {\r\n                direction = \"right\";\r\n            }\r\n            actionLockCounter = 0;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void update() {\r\n        setAction();\r\n        switch (direction) {\r\n            case \"up\" -> {\r\n                if (!collisionUp()) {\r\n                    y -= speed;\r\n                }\r\n            }\r\n            case \"down\" -> {\r\n                if (!collisionDown()) {\r\n                    y += speed;\r\n                }\r\n            }\r\n            case \"left\" -> {\r\n                if (!collisionLeft()) {\r\n                    x -= speed;\r\n                }\r\n            }\r\n            case \"right\" -> {\r\n                if (!collisionRight()) {\r\n                    x += speed;\r\n                }\r\n            }\r\n        }\r\n        spriteCounter++;\r\n        if (spriteCounter > 12) {\r\n            if (spriteNum == 1) {\r\n                spriteNum = 2;\r\n            } else if (spriteNum == 2) {\r\n                spriteNum = 1;\r\n            }\r\n            spriteCounter = 0;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void draw(Graphics2D g2) {\r\n        if (gp.bomberman.x <= gp.screenWidth / 2) {\r\n            if (direction.equals(\"left\")) {\r\n                g2.drawImage(balloonLeft[spriteNum], x, y, gp.tileSize, gp.tileSize, null);\r\n            } else if (direction.equals(\"right\")) {\r\n                g2.drawImage(balloonRight[spriteNum], x, y, gp.tileSize, gp.tileSize, null);\r\n            } else {\r\n                if (preDirection.equals(\"left\")) {\r\n                    g2.drawImage(balloonLeft[spriteNum], x, y, gp.tileSize, gp.tileSize, null);\r\n                } else {\r\n                    g2.drawImage(balloonRight[spriteNum], x, y, gp.tileSize, gp.tileSize, null);\r\n                }\r\n            }\r\n        } else if (gp.screenWidth / 2 <= gp.bomberman.x && gp.bomberman.x < gp.worldWidth - gp.screenWidth / 2 && x >= gp.screenWidth / 2) {\r\n            int ScreenX = x + gp.screenWidth / 2 - gp.bomberman.x;\r\n            if (direction.equals(\"left\")) {\r\n                g2.drawImage(balloonLeft[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n            } else if (direction.equals(\"right\")) {\r\n                g2.drawImage(balloonRight[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n            } else {\r\n                if (preDirection.equals(\"left\")) {\r\n                    g2.drawImage(balloonLeft[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n                } else {\r\n                    g2.drawImage(balloonRight[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n                }\r\n            }\r\n        } else if (gp.screenWidth / 2 <= gp.bomberman.x && x < gp.screenWidth / 2) {\r\n            int ScreenX = gp.screenWidth / 2 + this.x - gp.bomberman.x;\r\n            if (direction.equals(\"left\")) {\r\n                g2.drawImage(balloonLeft[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n            } else if (direction.equals(\"right\")) {\r\n                g2.drawImage(balloonRight[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n            } else {\r\n                if (preDirection.equals(\"left\")) {\r\n                    g2.drawImage(balloonLeft[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n                } else {\r\n                    g2.drawImage(balloonRight[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n                }\r\n            }\r\n        } else if (gp.bomberman.x > gp.worldWidth - gp.screenWidth / 2) {\r\n            int ScreenX = x - gp.worldWidth + gp.screenWidth;\r\n            if (direction.equals(\"left\")) {\r\n                g2.drawImage(balloonLeft[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n            } else if (direction.equals(\"right\")) {\r\n                g2.drawImage(balloonRight[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n            } else {\r\n                if (preDirection.equals(\"left\")) {\r\n                    g2.drawImage(balloonLeft[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n                } else {\r\n                    g2.drawImage(balloonRight[spriteNum], ScreenX, y, gp.tileSize, gp.tileSize, null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/GameObject/entity/Enemies.java b/src/GameObject/entity/Enemies.java
--- a/src/GameObject/entity/Enemies.java	(revision 1b1b81bc9f07efbdcf56268eb6e35798f17c5433)
+++ b/src/GameObject/entity/Enemies.java	(date 1666805729389)
@@ -49,7 +49,7 @@
 
     public void setAction() {
         actionLockCounter++;
-        if (actionLockCounter == 120) {
+        if (actionLockCounter == 80) {
             Random random = new Random();
             int i = random.nextInt(40) + 1;
             if (i <= 10) {
@@ -73,37 +73,7 @@
     @Override
     public void update() {
         setAction();
-        switch (direction) {
-            case "up" -> {
-                if (!collisionUp()) {
-                    y -= speed;
-                }
-            }
-            case "down" -> {
-                if (!collisionDown()) {
-                    y += speed;
-                }
-            }
-            case "left" -> {
-                if (!collisionLeft()) {
-                    x -= speed;
-                }
-            }
-            case "right" -> {
-                if (!collisionRight()) {
-                    x += speed;
-                }
-            }
-        }
-        spriteCounter++;
-        if (spriteCounter > 12) {
-            if (spriteNum == 1) {
-                spriteNum = 2;
-            } else if (spriteNum == 2) {
-                spriteNum = 1;
-            }
-            spriteCounter = 0;
-        }
+        super.updatePos();
     }
 
     @Override
Index: src/main/GamePanel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main;\r\n\r\n\r\nimport GameObject.Tiles.TileManager;\r\nimport GameObject.entity.Bomberman;\r\nimport GameObject.entity.Enemies;\r\nimport GameObject.entity.Oneal;\r\n\r\nimport javax.swing.*;\r\nimport java.awt.*;\r\n\r\n\r\npublic class GamePanel extends JPanel implements Runnable {\r\n    // SCREEN SETTINGS\r\n    public final int orignalTileSize = 16; //16x16 tile\r\n    public final int scale = 3;\r\n    public final int tileSize = orignalTileSize * scale; // Tile size --- 48x48\r\n    final int maxScreenCol = 16;\r\n    final int maxScreenRow = 13;\r\n    public final int screenWidth = tileSize * maxScreenCol;\r\n    public final int screenHeight = tileSize * maxScreenRow;\r\n    //Create object\r\n    Thread gameThread;\r\n    KeyHandler keyH = new KeyHandler(this);\r\n\r\n    public AssetSetter aSetter = new AssetSetter(this);\r\n    public Bomberman bomberman = new Bomberman(this, keyH);\r\n    public int lengthEnemies = 0, lengthOneal = 0;\r\n    public Enemies[] enemy;\r\n\r\n    public Oneal[] oneals;\r\n\r\n    Sound sound = new Sound();\r\n\r\n    //World Settings\r\n    public final int maxWorldCol = 31;\r\n    public final int maxWorldRow = 13;\r\n    public final int worldWidth = tileSize * maxWorldCol;\r\n    public final int worldHeight = tileSize * maxWorldRow;\r\n    //FPS\r\n    int FPS = 60;\r\n    TileManager tile = new TileManager(this);\r\n\r\n    //MENU\r\n    public int gameState;\r\n    public final int titleState = 0;\r\n    public final int playState = 1;\r\n    public final int loadLevel = 2;\r\n    public final int pauseState = 3;\r\n    public int loadGameInterval = -1;\r\n    public int commandNum = 0;\r\n    Menu menu = new Menu(this);\r\n\r\n\r\n    public GamePanel() {\r\n        this.setPreferredSize(new Dimension(screenWidth, screenHeight));\r\n        this.setBackground(Color.BLACK);\r\n        this.setDoubleBuffered(true);\r\n        this.addKeyListener(keyH);\r\n        this.setFocusable(true);\r\n        this.setUpGame();\r\n    }\r\n\r\n\r\n    public void setUpGame() {\r\n        gameState = titleState;\r\n        playMusic(0);\r\n        for (int i = 0; i < maxWorldRow; i++) {\r\n            for (int j = 0; j < maxWorldCol; j++) {\r\n                char s = tile.map[i][j];\r\n                if (s == '1') {\r\n                    lengthEnemies++;\r\n                }\r\n                if (s == '2') {\r\n                    lengthOneal++;\r\n                }\r\n            }\r\n        }\r\n        enemy = new Enemies[lengthEnemies];\r\n        oneals = new Oneal[lengthOneal];\r\n        int a = 0, b=0;\r\n        for (int i = 0; i < maxWorldRow; i++) {\r\n            for (int j = 0; j < maxWorldCol; j++) {\r\n                char s = tile.map[i][j];\r\n                if (s == '1') {\r\n                    enemy[a] = new Enemies(this);\r\n                    enemy[a].setEnemies(j * tileSize,i * tileSize);\r\n                    a++;\r\n                }\r\n                if (s ==  '2') {\r\n                    oneals[b] = new Oneal(this);\r\n                    oneals[b].setEnemies(j * tileSize, i*tileSize);\r\n                    b++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void startGameThread() {\r\n        gameThread = new Thread(this);\r\n        gameThread.start();\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        double drawInterval = 1000000000 / FPS;\r\n        double nextDrawTime = System.nanoTime() + drawInterval;\r\n        while (gameThread != null) {\r\n\r\n            update();\r\n\r\n            repaint();\r\n\r\n            try {\r\n                double remainingTime = nextDrawTime - System.nanoTime();\r\n                remainingTime /= 1000000;\r\n                if (remainingTime < 0) {\r\n                    remainingTime = 0;\r\n                }\r\n                Thread.sleep((long) remainingTime);\r\n                nextDrawTime += drawInterval;\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void update() {\r\n        bomberman.update();\r\n        for (Enemies enemies : enemy) {\r\n            if (enemies != null) {\r\n                enemies.update();\r\n            }\r\n        }\r\n        for (Oneal oneal : oneals) {\r\n            if (oneal != null) {\r\n                oneal.update();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void paintComponent(Graphics g) {\r\n        super.paintComponent(g);\r\n        Graphics2D g2 = (Graphics2D) g;\r\n        menu.draw(g2);\r\n        if (gameState == playState) {\r\n            //OTHERS\r\n            tile.draw(g2);\r\n            bomberman.draw(g2);\r\n            for (Enemies enemies : enemy) {\r\n                if (enemies != null) {\r\n                    enemies.draw(g2);\r\n                }\r\n            }\r\n            for (Oneal oneal : oneals) {\r\n                if (oneal != null) {\r\n                    oneal.draw(g2);\r\n                }\r\n            }\r\n        }\r\n        g2.dispose();\r\n    }\r\n\r\n\r\n    public int getTextCenterX(String text, Graphics2D g2) {\r\n        int length = (int) g2.getFontMetrics().getStringBounds(text, g2).getWidth();\r\n        return screenWidth / 2 - length / 2;\r\n    }\r\n\r\n    /*/\r\n    _______________________________________\r\n    |                                     |\r\n    |            MUSIC SETTINGS           |\r\n    |_____________________________________|\r\n     */\r\n    public void playMusic(int i) {\r\n        sound.setFile(i);\r\n        sound.play();\r\n        sound.loop();\r\n    }\r\n\r\n    public void stopMusic() {\r\n        sound.stop();\r\n    }\r\n\r\n    public void playSE(int i) {\r\n        sound.setFile(i);\r\n        sound.play();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/GamePanel.java b/src/main/GamePanel.java
--- a/src/main/GamePanel.java	(revision 1b1b81bc9f07efbdcf56268eb6e35798f17c5433)
+++ b/src/main/GamePanel.java	(date 1666804919679)
@@ -126,15 +126,17 @@
     }
 
     public void update() {
-        bomberman.update();
-        for (Enemies enemies : enemy) {
-            if (enemies != null) {
-                enemies.update();
-            }
-        }
-        for (Oneal oneal : oneals) {
-            if (oneal != null) {
-                oneal.update();
+        if (gameState == playState) {
+            bomberman.update();
+            for (Enemies enemies : enemy) {
+                if (enemies != null) {
+                    enemies.update();
+                }
+            }
+            for (Oneal oneal : oneals) {
+                if (oneal != null) {
+                    oneal.update();
+                }
             }
         }
     }
